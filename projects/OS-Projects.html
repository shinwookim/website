<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <!-- Metadata -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Course Projects for Operating Systems | Shinwoo Kim</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Course Projects for Operating Systems">
<meta name="author" content="Shinwoo Kim">
<meta property="og:locale" content="en_US">
<meta name="description" content="Below are some of my projects for the CS 1550: Operating Systems course that I took in Spring 2022 with Dr. Jon Misurda. A Linux Graphics Library Although printing to the terminal may amount only to a single line of code, beneath the veil of abstractions, it is a rather complex task. The computer, once it receives information on what characters to print, must calculate which pixels on the screen to manipulate by looking at the fonts, screen size, and screen type. This project explores how a computer does this by creating a custom graphics library and driver that can be used to draw and write to the screen. For this project, no external libraries were used (not even the C standard library) except for the system calls provided by the Linux operating system. /dev/cards: Virtual Device Driver This project alters how the Linux operating system interacts with devices by creating a specific implementation of the read() system call for a software-emulated device. This project explores the OS’s system calls as a device-independent interface that user space programs can use to request the OS to do various tasks that it may not be able to do itself. Following the Unix ethos of “Everything is a file”, cards device driver can be mounted to the /dev/ virtual filesystem which represents the hardware devices that are attatched to a system. In a similar manner to the virtual device drivers that are common to Linux (e.g., /dev/zero and /dev/random), the /dev/cards device driver returns a randomly selected playing card simulating a real card deck. As such, each card needs to be tracked to ensure that it is not returned again until all 52 cards have been exhausted. To test the newly created device driver, a driver program which emulates a simple Blackjack game (User vs. CPU) is implemented. Syscalls and Interprocess Communication Anytime we have shared data between two or more processes or threads, we run the risk of having a race condition where our data could become corrupted. In order to avoid these situations, we have discussed various mechanisms to ensure that one program’s critical regions are guarded from another’s. One place that we might use parallelism is to simulate real-world situations that involve multiple independently acting entities, such as people or automobiles. This project models a common roadway occurrence, where a lane is closed and a flagperson is directing traffic. In addition, to implement this program, we modify the Linux kernel to create custom system calls that help us implement custom synchronization primitives. Virtual Memory Simulator One of the most important abstractions provided by the operating system is the notion of exclusive access to memory. A operating system accomplishes this by using a scheme called virtual memory (and paging) that allow for allocating chunks of a processes’ address space onto physical RAM. Yet, one of the pitfalls of this scheme is the performance loss when a page-fault occurs. This project explores how we can optimize the various page replacement algorithms by using a simulation to count and analyze the number of page faults. Custom File System How does a computer store files and metadata? Using FUSE, this project implements various file-related system calls to create a custom file system that is managed via a single file that represents the disk device. Using FUSE and the project’s implementation, we can interact with the custom file system using standard UNIX/Linux programs in a transparent way. Code Available Upon Request">
<meta property="og:description" content="Below are some of my projects for the CS 1550: Operating Systems course that I took in Spring 2022 with Dr. Jon Misurda. A Linux Graphics Library Although printing to the terminal may amount only to a single line of code, beneath the veil of abstractions, it is a rather complex task. The computer, once it receives information on what characters to print, must calculate which pixels on the screen to manipulate by looking at the fonts, screen size, and screen type. This project explores how a computer does this by creating a custom graphics library and driver that can be used to draw and write to the screen. For this project, no external libraries were used (not even the C standard library) except for the system calls provided by the Linux operating system. /dev/cards: Virtual Device Driver This project alters how the Linux operating system interacts with devices by creating a specific implementation of the read() system call for a software-emulated device. This project explores the OS’s system calls as a device-independent interface that user space programs can use to request the OS to do various tasks that it may not be able to do itself. Following the Unix ethos of “Everything is a file”, cards device driver can be mounted to the /dev/ virtual filesystem which represents the hardware devices that are attatched to a system. In a similar manner to the virtual device drivers that are common to Linux (e.g., /dev/zero and /dev/random), the /dev/cards device driver returns a randomly selected playing card simulating a real card deck. As such, each card needs to be tracked to ensure that it is not returned again until all 52 cards have been exhausted. To test the newly created device driver, a driver program which emulates a simple Blackjack game (User vs. CPU) is implemented. Syscalls and Interprocess Communication Anytime we have shared data between two or more processes or threads, we run the risk of having a race condition where our data could become corrupted. In order to avoid these situations, we have discussed various mechanisms to ensure that one program’s critical regions are guarded from another’s. One place that we might use parallelism is to simulate real-world situations that involve multiple independently acting entities, such as people or automobiles. This project models a common roadway occurrence, where a lane is closed and a flagperson is directing traffic. In addition, to implement this program, we modify the Linux kernel to create custom system calls that help us implement custom synchronization primitives. Virtual Memory Simulator One of the most important abstractions provided by the operating system is the notion of exclusive access to memory. A operating system accomplishes this by using a scheme called virtual memory (and paging) that allow for allocating chunks of a processes’ address space onto physical RAM. Yet, one of the pitfalls of this scheme is the performance loss when a page-fault occurs. This project explores how we can optimize the various page replacement algorithms by using a simulation to count and analyze the number of page faults. Custom File System How does a computer store files and metadata? Using FUSE, this project implements various file-related system calls to create a custom file system that is managed via a single file that represents the disk device. Using FUSE and the project’s implementation, we can interact with the custom file system using standard UNIX/Linux programs in a transparent way. Code Available Upon Request">
<link rel="canonical" href="https://sites.pitt.edu/~shk148/projects/OS-Projects.html">
<meta property="og:url" content="https://sites.pitt.edu/~shk148/projects/OS-Projects.html">
<meta property="og:site_name" content="Shinwoo Kim">
<meta property="og:image" content="https://lp-cms-production.imgix.net/2019-06/b620bbff71a0adb8fd86ee311fdba089-cathedral-of-learning.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-05-28T19:16:19-04:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:image" content="https://lp-cms-production.imgix.net/2019-06/b620bbff71a0adb8fd86ee311fdba089-cathedral-of-learning.jpg">
<meta property="twitter:title" content="Course Projects for Operating Systems">
<meta name="twitter:site" content="@_shinwookim">
<meta name="twitter:creator" content="@Shinwoo Kim">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Shinwoo Kim"},"dateModified":"2024-05-28T19:16:19-04:00","datePublished":"2024-05-28T19:16:19-04:00","description":"Below are some of my projects for the CS 1550: Operating Systems course that I took in Spring 2022 with Dr. Jon Misurda. A Linux Graphics Library Although printing to the terminal may amount only to a single line of code, beneath the veil of abstractions, it is a rather complex task. The computer, once it receives information on what characters to print, must calculate which pixels on the screen to manipulate by looking at the fonts, screen size, and screen type. This project explores how a computer does this by creating a custom graphics library and driver that can be used to draw and write to the screen. For this project, no external libraries were used (not even the C standard library) except for the system calls provided by the Linux operating system. /dev/cards: Virtual Device Driver This project alters how the Linux operating system interacts with devices by creating a specific implementation of the read() system call for a software-emulated device. This project explores the OS’s system calls as a device-independent interface that user space programs can use to request the OS to do various tasks that it may not be able to do itself. Following the Unix ethos of “Everything is a file”, cards device driver can be mounted to the /dev/ virtual filesystem which represents the hardware devices that are attatched to a system. In a similar manner to the virtual device drivers that are common to Linux (e.g., /dev/zero and /dev/random), the /dev/cards device driver returns a randomly selected playing card simulating a real card deck. As such, each card needs to be tracked to ensure that it is not returned again until all 52 cards have been exhausted. To test the newly created device driver, a driver program which emulates a simple Blackjack game (User vs. CPU) is implemented. Syscalls and Interprocess Communication Anytime we have shared data between two or more processes or threads, we run the risk of having a race condition where our data could become corrupted. In order to avoid these situations, we have discussed various mechanisms to ensure that one program’s critical regions are guarded from another’s. One place that we might use parallelism is to simulate real-world situations that involve multiple independently acting entities, such as people or automobiles. This project models a common roadway occurrence, where a lane is closed and a flagperson is directing traffic. In addition, to implement this program, we modify the Linux kernel to create custom system calls that help us implement custom synchronization primitives. Virtual Memory Simulator One of the most important abstractions provided by the operating system is the notion of exclusive access to memory. A operating system accomplishes this by using a scheme called virtual memory (and paging) that allow for allocating chunks of a processes’ address space onto physical RAM. Yet, one of the pitfalls of this scheme is the performance loss when a page-fault occurs. This project explores how we can optimize the various page replacement algorithms by using a simulation to count and analyze the number of page faults. Custom File System How does a computer store files and metadata? Using FUSE, this project implements various file-related system calls to create a custom file system that is managed via a single file that represents the disk device. Using FUSE and the project’s implementation, we can interact with the custom file system using standard UNIX/Linux programs in a transparent way. Code Available Upon Request","headline":"Course Projects for Operating Systems","image":"https://lp-cms-production.imgix.net/2019-06/b620bbff71a0adb8fd86ee311fdba089-cathedral-of-learning.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://sites.pitt.edu/~shk148/projects/OS-Projects.html"},"url":"https://sites.pitt.edu/~shk148/projects/OS-Projects.html"}</script>
<!-- End Jekyll SEO tag -->

<!-- End Metadata -->

  <!-- Styles -->
<link rel="stylesheet" type="text/css" href="/~shk148/assets/css/bootstrap.css">
<link rel="stylesheet" type="text/css" href="/~shk148/assets/css/main.css">
<link rel="stylesheet" type="text/css" href="/~shk148/assets/css/fonts-et-book.css">
<link rel="stylesheet" type="text/css" href="/~shk148/assets/css/fonts-autography.css">

<link rel="stylesheet" type="text/css" href="/~shk148/assets/css/lightbox.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin="anonymous" referrerpolicy="no-referrer">

<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/~shk148/assets/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/~shk148/assets/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/~shk148/assets/favicon/favicon-16x16.png">
<link rel="icon" type="image/x-icon" sizes="32x32" href="/~shk148/assets/favicon/favicon.ico">
<link rel="manifest" href="/~shk148/assets/favicon/manifest.json">

<!-- End Styles-->

<!-- <link rel="stylesheet" type="text/css" href="/~shk148/assets/css/fonts-lato.css" /> -->
</head>

<body>
  <button type="button" class="toggle-theme" id="color-selecter"></button>
  <div class="container mt-5">
	<div class="row pt-5">
		<div class="col-md">
			<header class="text-md-end text-center">
    <div class="display-3 my-0">
        <a class="nav-link no-tufte-underline text-md-end fw-bolder autography" href="/~shk148/">Shinwoo<br>Kim</a>
    </div>
    <div class="w-100 my-0">
        <code class="h2">
            <span class="typed" data-typed-items="Software Engineer, Developer, Pitt Panther, Educator"></span>
        </code>
    </div>
    <div class="mb-0">
        <a class="no-tufte-underline h3" href="mailto:shinwookim@pitt.edu"><i class="fas fa-envelope"></i></a>
        <a class="no-tufte-underline h3" href="https://linkedin.com/in/kimshinwoo"><i class="fab fa-linkedin-in"></i></a>
        <a class="no-tufte-underline h3" href="https://github.com/shinwookim"><i class="fab fa-github"></i></a>
        <a class="no-tufte-underline h3" href="https://twitter.com/_shinwookim"><i class="fab fa-twitter"></i></a>
    </div>
</header>
<!-- Site Navigation-->
<nav class="d-block navbar navbar-expand-md mb-4 p-0 text-center">
    <button aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler collapsed mt-3" data-bs-target="#navbar" data-bs-toggle="collapse" type="button">
        <i class="fas fa-bars"></i>
    </button>
    <div class="navbar-collapse collapse" id="navbar">
        <ul class="flex-column ms-md-auto nav mt-3 text-center">
            <li>
                <a class="nav-link no-tufte-underline float-md-end " href="/~shk148/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link no-tufte-underline float-md-end " href="/~shk148/about/">About Me
                </a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link no-tufte-underline float-md-end " href="/~shk148/resume/">Résumé
                </a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link no-tufte-underline float-md-end fw-bold" href="/~shk148/projects/">Projects
                </a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link no-tufte-underline float-md-end " href="/~shk148/teaching/">Teaching
                </a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link no-tufte-underline float-md-end " href="/~shk148/contact/">Contact Me
                </a>
            </li>
            
        </ul>
    </div>
</nav>
<script src="https://unpkg.com/typed.js@2.0.16/dist/typed.umd.js"></script>
<script src="/~shk148/assets/js/typed.js"></script>
		</div>
		<div class="col-md-8">
			<style>
  img {
    transition: 0.5s ease;
    margin: auto;
    border-radius: var(--bs-border-radius) !important;
  }

  table {
    margin: auto;
  }

  img:hover {
    scale: 1.01;
  }

  img {
    max-width: 100%;
    height: auto;
  }
</style>
<h1>
  
  
    Course Projects for Operating Systems
  
  
</h1>
    
<p class="subtitle mb-3 mt-0"></p>
<div class="mb-2">
  
  <span class="badge rounded-pill text-bg-info mx-1">C</span>
  
  <span class="badge rounded-pill text-bg-info mx-1">Kernel Development</span>
  
  <span class="badge rounded-pill text-bg-info mx-1">Linux</span>
  
  <span class="badge rounded-pill text-bg-info mx-1">Operating Systems</span>
  
</div>

<p>Below are some of my projects for the CS 1550: Operating Systems course that I took in Spring 2022 with Dr. Jon Misurda.</p>
<h2 id="a-linux-graphics-library">
  
  
    
  
  
    A Linux Graphics Library <a href="#a-linux-graphics-library" class="anchor-link">¶</a>
  
  
 <a href="#a-linux-graphics-library" class="anchor-link">¶</a>
  
  
</h2>
    
    
<p>Although printing to the terminal may amount only to a single line of code, beneath the veil of abstractions, it is a rather complex task. The computer, once it receives information on what characters to print, must calculate which pixels on the screen to manipulate by looking at the fonts, screen size, and screen type. This project explores how a computer does this by creating a custom graphics library and driver that can be used to draw and write to the screen.</p>

<p>For this project, no external libraries were used (not even the C standard library) except for the system calls provided by the Linux operating system.</p>
<h2 id="devcards-virtual-device-driver">
  
  
    
  
  
    <code class="language-plaintext highlighter-rouge">/dev/cards</code>: Virtual Device Driver <a href="#devcards-virtual-device-driver" class="anchor-link">¶</a>
  
  
 <a href="#devcards-virtual-device-driver" class="anchor-link">¶</a>
  
  
</h2>
    
    
<p>This project alters how the Linux operating system interacts with devices by creating a specific implementation of the <code class="language-plaintext highlighter-rouge">read()</code> system call for a software-emulated device. This project explores the OS’s system calls as a device-independent interface that user space programs can use to request the OS to do various tasks that it may not be able to do itself.</p>

<p>Following the Unix ethos of “<em>Everything is a file</em>”, <code class="language-plaintext highlighter-rouge">cards</code> device driver can be mounted to the <code class="language-plaintext highlighter-rouge">/dev/</code> virtual filesystem which represents the hardware devices that are attatched to a system. In a similar manner to the virtual device drivers that are common to Linux (e.g., <code class="language-plaintext highlighter-rouge">/dev/zero</code> and <code class="language-plaintext highlighter-rouge">/dev/random</code>), the <code class="language-plaintext highlighter-rouge">/dev/cards</code> device driver returns a randomly selected playing card simulating a real card deck. As such, each card needs to be tracked to ensure that it is not returned again until all 52 cards have been exhausted.</p>

<p>To test the newly created device driver, a driver program which emulates a simple Blackjack game (User vs. CPU) is implemented.</p>
<h2 id="syscalls-and-interprocess-communication">
  
  
    
  
  
    Syscalls and Interprocess Communication <a href="#syscalls-and-interprocess-communication" class="anchor-link">¶</a>
  
  
 <a href="#syscalls-and-interprocess-communication" class="anchor-link">¶</a>
  
  
</h2>
    
    
<p>Anytime we have shared data between two or more processes or threads, we run the risk of having a <em>race condition</em> where our data could become corrupted. In order to avoid these situations, we have discussed various mechanisms to ensure that one program’s critical regions are guarded from another’s.</p>

<p>One place that we might use parallelism is to simulate real-world situations that involve multiple independently acting entities, such as people or automobiles. This project models a common roadway occurrence, where a lane is closed and a flagperson is directing traffic. In addition, to implement this program, we modify the Linux kernel to create <em>custom system calls</em> that help us implement custom synchronization primitives.</p>
<h2 id="virtual-memory-simulator">
  
  
    
  
  
    Virtual Memory Simulator <a href="#virtual-memory-simulator" class="anchor-link">¶</a>
  
  
 <a href="#virtual-memory-simulator" class="anchor-link">¶</a>
  
  
</h2>
    
    
<p>One of the most important abstractions provided by the operating system is the notion of exclusive access to memory. A operating system accomplishes this by using a scheme called <strong>virtual memory</strong> (and paging) that allow for allocating chunks of a processes’ address space onto physical RAM. Yet, one of the pitfalls of this scheme is the performance loss when a <em>page-fault</em> occurs. This project explores how we can optimize the various page replacement algorithms by using a simulation to count and analyze the number of page faults.</p>
<h2 id="custom-file-system">
  
  
    
  
  
    Custom File System <a href="#custom-file-system" class="anchor-link">¶</a>
  
  
 <a href="#custom-file-system" class="anchor-link">¶</a>
  
  
</h2>
    
    
<p>How does a computer store files and metadata? Using <a href="https://github.com/libfuse/libfuse">FUSE</a>, this project implements various file-related system calls to create a custom file system that is managed via a single file that represents the disk device. Using FUSE and the project’s implementation, we can interact with the custom file system using standard UNIX/Linux programs in a transparent way.</p>

<p class="text-center"><strong>Code Available Upon Request</strong></p>

		</div>
	</div>
</div>
  <div class="container">
	<footer class="d-flex flex-wrap justify-content-between align-items-center py-3 my-4 border-top">
		<div class=" d-flex align-middle">
			<a class="no-tufte-underline text-md-end fw-bolder autography h3 mx-2" href="/~shk148/">Shinwoo
				Kim</a>
			<span class="mb-3 mb-md-0 text-body-secondary"> © 2020 - 2024,
				<a href="mailto:shinwookim@pitt.edu">Shinwoo Kim</a>. All Rights Reserved.
			</span>

		</div>
		<ul class="nav col-md-4 justify-content-end list-unstyled d-flex">
			<li class="ms-3"><a class="no-tufte-underline" href="https://twitter.com/_shinwookim"><i class="fab fa-twitter"></i></a></li>
			<li class="ms-3"><a class="no-tufte-underline" href="https://github.com/shinwookim"><i class="fab fa-github"></i></a></li>
			<li class="ms-3">
<a class="no-tufte-underline" href="https://linkedin.com/in/kimshinwoo"><i class="fab fa-linkedin-in"></i></a>
			</li>
		</ul>
	</footer>
</div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
<script src="/~shk148/assets/js/darkmode.js"></script>
<script src="/~shk148/assets/js/lightbox.js"></script>
<script data-name="BMC-Widget" data-cfasync="false" src="/~shk148/assets/js/coffee.js" data-id="shinwookim" data-description="Support me on Buy me a coffee!" data-message="" data-color="#fff" data-position="Right" data-x_margin="12" data-y_margin="12"></script>
<script>
  // Enable Bootstrap Tooltips
  // See: https://getbootstrap.com/docs/5.3/components/tooltips/
  const tooltipTriggerList = document.querySelectorAll(
    '[data-bs-toggle="tooltip"]'
  );
  const tooltipList = [...tooltipTriggerList].map(
    (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
  );
</script>
</body>

</html>
